<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - helpers</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!--<link type="text/css" rel="stylesheet" href="main.css">-->
		<style>

#info {
	position: absolute;
	bottom: 10px;
	right: 20px;
	width: 100%;
	float:right;
	text-align:right;
	z-index: 1;
			//	margin-left: auto;
			//	margin-right: auto;
			}


			#lineup {
	position: absolute;
	top: 10px;
	left: 20px;
	width: 100%;
	float:left;
	text-align:left;
	z-index: 1;
				margin-left: auto;
				margin-right: auto;
			}
					
					
			
			@font-face {
			font-family: "ft88";
			src: "FT88-Expanded.ttf";
			}

			body {
				margin: 0;
				color: #fff;
				width:100%;
				font-size: 13px;
				line-height: 24px;
				overscroll-behavior: none;
				background-image: linear-gradient(red, yellow);
				font-family: "ft88";
				overflow:hidden;
			}

			#renderer{
				margin:0px;
				height:100%;
				width:100%;
				left:0px;
				position:absolute;
			}

			#stats{
				bottom:0px;
				position:absolute;
			}
			</style>
	</head>
	<body>

		<div id="lineup">
			<a href="https://threejs.org" target="_blank">AG Cook</a><br/>
			<a href="https://threejs.org" target="_blank">รถ</a><br/>
			<a href="https://threejs.org" target="_blank">Alex Somers</a><br/>

		</div>

		<div id="info">
			<a href="https://threejs.org" target="_blank">twitch.tv/pcmusic</a><br/>
			<a href="https://threejs.org" target="_blank">Dec 11th</a><br/>
			<a href="https://threejs.org" target="_blank">5PM EST</a><br/>

			
		</div>
		<script src="lib/jquery.min.js"></script>
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>




		

		<script type="module">

			import * as THREE from 'three';
import {
	Box3,
	MathUtils,
	Matrix4,
	Matrix3,
	Ray,
	Vector3,
	Color,
	TextureLoader
} from 'three';

import{ ShaderLoader } from './lib/ShaderLoader.js';

			import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
			import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

			import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
			import { VertexTangentsHelper } from 'three/addons/helpers/VertexTangentsHelper.js';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
			
			import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';

			import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
			import { HalftonePass } from 'three/addons/postprocessing/HalftonePass.js';

			
			import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
			import { DotScreenPass } from 'three/addons/postprocessing/DotScreenPass.js';
			import { TexturePass } from 'three/addons/postprocessing/TexturePass.js';

			import { BleachBypassShader } from 'three/addons/shaders/BleachBypassShader.js';
			import { ColorifyShader } from 'three/addons/shaders/ColorifyShader.js';
			import { HorizontalBlurShader } from 'three/addons/shaders/HorizontalBlurShader.js';
			import { VerticalBlurShader } from 'three/addons/shaders/VerticalBlurShader.js';
			import { SepiaShader } from 'three/addons/shaders/SepiaShader.js';
			import { VignetteShader } from 'three/addons/shaders/VignetteShader.js';
			import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';
			import { BokehShader, BokehDepthShader } from 'three/addons/shaders/BokehShader2.js';
			
			import { PixelShader } from 'three/addons/shaders/PixelShader.js';

			import { TransformControls } from 'three/addons/controls/TransformControls.js';
			import { Flow } from 'three/addons/modifiers/CurveModifier.js';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';


			import * as Curves from 'three/addons/curves/CurveExtras.js';
			
			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			const ACTION_SELECT = 1, ACTION_NONE = 0;
			const curveHandles = [];
			const mouse = new THREE.Vector2();

			let scene, renderer;
			let camera, light;
			let vnh;
			let vth;
			let composer,  mixer;
			let pixelPass,	control,
				flow, rayCaster,
				action = ACTION_NONE;

				let stats;


			var neededToLoad = 0;
			var numLoaded = 0;

			var shaders = new ShaderLoader( 'shaders' );


			addLoad();

			shaders.load( 'fs-trace3'  , 'trace2' , 'fragment' );
shaders.load( 'vs-trace2'  , 'trace2' , 'vertex'   );
shaders.load( 'fs-trace'  , 'trace' , 'fragment' );
shaders.load( 'vs-trace'  , 'trace' , 'vertex'   );
shaders.load( 'vs-gradient'  , 'gradient' , 'vertex'   );
shaders.load( 'fs-gradient'  , 'gradient' , 'fragment'   );


shaders.shaderSetLoaded = function(){

	console.log("LOADED");
  onLoad();
}




var textureLoader = new TextureLoader();
	addLoad();
  var matcap = textureLoader.load('img/rough-aluminium.jpg',function ( texture ) {
    onLoad();
  });

  addLoad();
  var diffuseRock = textureLoader.load('img/Textures_8K/WallRock_Diffuse_8K.jpg',function ( texture ) {
    onLoad();
  });




addLoad();
  const ttfLoader = new TTFLoader()
const fontLoader = new FontLoader();
				ttfLoader.load( 'fonts/FT88-Expanded.ttf', function( fnt) {

					const font = fontLoader.parse(fnt)

					var geometry = new TextGeometry( 'away from keyboard', {
						font: font,
						size: .04,
						height: .01,
						curveSegments: 12,
						bevelEnabled: false,
						bevelThickness: 0.00,
						bevelSize: 0.01,
						bevelOffset: 0,
						bevelSegments: 5,
					} );

					geometry.rotateX( Math.PI  * -.5);

					fontGeo = geometry;


					var geometry = new TextGeometry( 'AFK', {
						font: font,
						size: .5,
						height: .1,
						curveSegments: 12,
						bevelEnabled: true,
						bevelThickness: 0.02,
						bevelSize: 0.01,
						bevelOffset: 0,
						bevelSegments: 5,
					} );

					geometry.rotateX( Math.PI  * -.5);

					fontGeo2 = geometry;

					onLoad();

				} );



  	const objLoader = new OBJLoader();
	var afkModel;

	addLoad();
	objLoader.load( 'img/afk_lowerCase2.obj', function ( gltf ) {
		onLoad();
		afkModel = gltf.children[ 0 ];

	} );

	var rockModel;

	addLoad();
	objLoader.load( 'img/WallRock_obj/WallRock_obj.obj', function ( gltf ) {

rockModel = gltf.children[ 0 ];
onLoad();

} );



var tubeModel;

addLoad();
objLoader.load( 'cone.obj', function ( gltf ) {

console.log("hiii");

tubeModel = gltf.children[ 0 ];
console.log(tubeModel);
onLoad();

} );

var fernModel;

addLoad();
objLoader.load( 'img/matteucia_struthiopteris_loPoly.obj', function ( gltf ) {

fernModel = gltf.children[ 0 ];
onLoad();

} );



var computerModel;

addLoad();
objLoader.load( 'img/computerOBJ.obj', function ( gltf ) {

computerModel = gltf.children[ 0 ];
onLoad();

} );


addLoad();
  var diffuseFern = textureLoader.load('img/msMaps/matteuccia_struthiopteris_leaf_1_01_diffuse.jpg',function ( texture ) {
    onLoad();
  });

  addLoad();
  var normalFern = textureLoader.load('img/msMaps/matteuccia_struthiopteris_leaf_1_04_normal.jpg',function ( texture ) {
    onLoad();
  });


  addLoad();
  var specularFern = textureLoader.load('img/msMaps/matteuccia_struthiopteris_leaf_1_02_specular.jpg',function ( texture ) {
    onLoad();
  });


  addLoad();
  var bumpFern = textureLoader.load('img/msMaps/matteuccia_struthiopteris_leaf_bump.jpg',function ( texture ) {
    onLoad();
  });



	
	var uniforms = {

dT:       { type:"f"  , value : 0             },
time:     { type:"f"  , value : 0             },
lightPos: { type:"v3" , value : null          },
t_matcap: { type:"t", value: matcap},

_NoiseSize:{type:"f",value:.4},
_NoiseSpeed:{type:"f",value:.2},
_NoiseOffset:{type:"f",value:.3},
_HueStart:{type:"f",value:.1},
_HueSize:{type:"f",value:.0004},
_NormalDepth:{type:"f",value:1.1},
_FFTStart:{type:"f",value:.1},
_FFTSize:{type:"f",value:.1},
_Saturation:{type:"f",value:.6},
_Lightness:{type:"f",value:0},
_DiscardAmount:{type:"f",value:.9}

}


var lorenz
const params = {
				exposure: 0,
				bloomStrength:.3,
				bloomThreshold: 0,
				bloomRadius: 0,	shape: 1,
					radius: 4,
					rotateR: Math.PI / 12,
					rotateB: Math.PI / 12 * 2,
					rotateG: Math.PI / 12 * 3,
					scatter: 0,
					blending: 1,
					blendingMode: 1,
					greyscale: false,
					disable: false,
					pixelSize: 2,
					postprocessing: true,
					
					focus: 400.0,
					aperture: 5,
					maxblur: 0.01

					
			};


var clock = new THREE.Clock();


var spiralGeo;
let fontGeo;
let fontGeo2;

			//init();
			//animate();

			function init() {





	




				renderer = new THREE.WebGLRenderer( { alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.domElement.id = "renderer";
				//renderer.info.alpha = true;
				document.body.appendChild( renderer.domElement );
				

				
				stats = new Stats();
				stats.dom.id = "stats";
				stats.dom.style = "";
				document.body.appendChild( stats.dom );


				//renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.setClearColor(0x00f000, 1)

				//

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 4, 40000 );
				camera.position.z = 800;

				scene = new THREE.Scene();
				scene.background = null;

				//light = new THREE.PointLight();
				//light.position.set( 200, 100, 150 );
				//scene.add( light );

				//scene.add( new THREE.PointLightHelper( light, 20 ) );



				var size = 1;

				var initialPoints = []
				for( var i = 0; i < 100; i++ ){


					var angle = i * .5;
					var radius = .005 * i + 2 ;
					var height = .01;

					

					var p = {
						x: -Math.cos( angle ) * radius,
						z: Math.sin(angle) * radius,
						y: i * height - 1
					}
					initialPoints.push(p);

				}


				
				var initialPoints = []
				for( var i = 0; i < 10; i++ ){


					var angle = (i /10)* 2 * Math.PI;
					var radius = 2 ;
					var height = .01;

					

					var p = {
						x: -Math.cos( angle ) * radius,
						z: Math.sin(angle) * radius,
						y: 0
					}
					initialPoints.push(p);

				}
				/*const initialPoints = [
					{ x: -size, y: .1 * size	, z: - size },
					{ x: -size/2, y: -1 * size, z: -size/2},
					{ x:  size/2, y: -1 * size, z: - size },
					{ x: size, y: .1, z: - size/2 },
					{ x: size, y: .1, z:  size/2 },
					{ x: -size, y: .1, z: size },
					//{ x:  size, y: 100, z: - size },
					//{ x: size, y: 100, z: - size },
				];*/

				const boxGeometry = new THREE.BoxGeometry( 40,40, 40);
				const boxMaterial = new THREE.MeshBasicMaterial({color:0x00ff00});

				for ( const handlePos of initialPoints ) {

					const handle = new THREE.Mesh( boxGeometry, boxMaterial );
					handle.position.copy( handlePos );
					curveHandles.push( handle );
					//scene.add( handle );

				}

				const curve = new THREE.CatmullRomCurve3(
					curveHandles.map( ( handle ) => handle.position )
				);
				curve.curveType = 'centripetal';
				curve.closed = true;

				const points = curve.getPoints( 20 );
				const line = new THREE.LineLoop(
					new THREE.BufferGeometry().setFromPoints( points ),
					new THREE.LineBasicMaterial( { color: 0x00ff00 } )
				);


				var gridHelper = new THREE.GridHelper( 2000, 50, 0x000000, 0x000000 );
				gridHelper.position.y = - 150;
				gridHelper.position.x = 0;
				//gridHelper.rotation.x = .1;
				//scene.add( gridHelper );

				var gridHelper = new THREE.GridHelper( 2000, 50, 0x000000, 0x000000 );
				gridHelper.position.y = 150;
				gridHelper.position.x = 0;
				gridHelper.rotation.x = -.1;
				//scene.add( gridHelper );

				const polarGridHelper = new THREE.PolarGridHelper( 200, 16, 8, 64, 0x000000, 0x808080 );
				polarGridHelper.position.y = - 150;
				polarGridHelper.position.x = 200;
				//scene.add( polarGridHelper );

				const group = new THREE.Group();
				group.scale.multiplyScalar( 100 );
				group.rotation.x = 3.14159/2
				scene.add( group );
				//group.add( line );

				// To make sure that the matrixWorld is up to date for the boxhelpers
				group.updateMatrixWorld( true );
				var lor = []

let x0 = 0.1;
let y0 = 0;
let z0 = 0; 
let x1, y1, z1;
let h = 0.001;
let a = 10.0;
let b = 28.0;
let c = 7.0 / 3.0;


var len = 100000;
for (let i = 0; i < len; i++) {
x1 = x0 + h * a * (y0 - x0);
y1 = y0 + h * (x0 * (b - z0) - y0);
z1 = z0 + h * (x0 * y0 - c * z0);
x0 = x1;
y0 = y1;
z0 = z1;
let vertex = new THREE.Vector3(
 x0, 
 y0, 
 z0-24);
lor.push(vertex);
}
   var curve2 = new THREE.CatmullRomCurve3(lor
		   );
		   curve2.curveType = 'centripetal';
		   curve2.closed = false;



		   var matte = new THREE.MeshBasicMaterial({
			color: new THREE.Color(0,0,0), 
			transparent:true,
			opacity: .3
		});
var tubeGeometry2 = new THREE.TubeGeometry( curve2,10000, .1, 3 );

	 var pretty  =new THREE.Mesh( tubeGeometry2 , matte);
   
   pretty.rotation.z = Math.PI / 2;
   //pretty.rotation.y = 1;
   pretty.position.y = -4;
   var s = .1;
   pretty.scale.set(s,s,s);

   lorenz = pretty;

   group.add(pretty);


				var raytraceMat2 = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: shaders.vs.trace2,
        fragmentShader: shaders.fs.trace2,
        side: THREE.DoubleSide,
		//depthTest: false,
		//wireframe : true,
      })



		var pretty  =new THREE.Mesh( tubeModel.geometry , raytraceMat2 );
		
		var s = 10;
		pretty.position.y = 1;
		pretty.rotation.x = Math.PI;
		pretty.scale.set(s,s*10,s);
		group.add(pretty);






	 // var curve1 = new Curves.GrannyKnot(.1);
/*
	 var matte = new THREE.MeshBasicMaterial({color: new THREE.Color(0,0,0)});
	  let tubeGeometry = new THREE.TubeGeometry( curve,100, .01, 3 );


	  var s2 = new THREE.ShaderMaterial({
    uniforms: {
      uColorA: { value: new THREE.Color(1,.8,1) },
      uColorB: { value: new THREE.Color(1,.8,0) }
    },
        vertexShader: shaders.vs.gradient,
        fragmentShader: shaders.fs.gradient
  })
	  	var pretty  =new THREE.Mesh( tubeGeometry , matte);
		
		pretty.rotation.x = .4;
		pretty.rotation.y = .3;
		pretty.position.x = 2;
		var s = .5;
		pretty.scale.set(s,s,s);

		spiralGeo = pretty;


		//group.add(pretty);
				



	
		var pretty  =new THREE.Mesh( tubeGeometry , matte);
		
		pretty.rotation.x = .7;
		pretty.rotation.y = .3;
		pretty.position.x = -2;
		var s = .5;
		pretty.scale.set(s,s,s);

		spiralGeo = pretty;


		//group.add(pretty);

*/





		



var raytraceMat = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: shaders.vs.trace,
        fragmentShader: shaders.fs.trace,
       // side: THREE.DoubleSide,
		//depthTest: false,
		wireframe : true,
		//transparent: true,
		//opacity:.5,
		//blending:THREE.AdditiveBlending,
      })

				/*var pretty = new THREE.Mesh( afkModel.geometry , matte);
				//group.add( pretty );

				var pretty = new THREE.Mesh( afkModel.geometry , new THREE.MeshBasicMaterial({color: new THREE.Color(0,0,0)}));
				//group.add( pretty );*/

				var pretty = new THREE.Mesh( afkModel.geometry , raytraceMat);
				//pretty.position.y = 5;
				group.add( pretty );

			


		


				var myGradient = new THREE.Mesh(
  new THREE.PlaneGeometry(20,20,1,1),
  new THREE.ShaderMaterial({
    uniforms: uniforms,
        vertexShader: shaders.vs.gradient,
        fragmentShader: shaders.fs.gradient
  })
)

myGradient.material.depthWrite = false
myGradient.renderOrder = -99999
myGradient.position.x = 100

scene.add(myGradient);


			

				window.addEventListener( 'resize', onWindowResize );


				const renderScene = new RenderPass( scene, camera );

const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
bloomPass.threshold = params.bloomThreshold;
bloomPass.strength = params.bloomStrength;
bloomPass.radius = params.bloomRadius;


pixelPass = new ShaderPass( PixelShader );
				pixelPass.uniforms[ 'resolution' ].value = new THREE.Vector2( window.innerWidth, window.innerHeight );
				pixelPass.uniforms[ 'resolution' ].value.multiplyScalar( window.devicePixelRatio );



const halftonePass = new HalftonePass( window.innerWidth, window.innerHeight, params );

const bokehPass = new BokehPass( scene, camera, params);

const effectFilm = new FilmPass( 0.35, .01, 1, false );

composer = new EffectComposer( renderer );
composer.addPass( renderScene );
//composer.addPass( bloomPass );
composer.addPass(effectFilm);
//composer.addPass( bokehPass );
//composer.addPass(pixelPass);







				renderer.domElement.addEventListener( 'pointerdown', onPointerDown );
				
				rayCaster = new THREE.Raycaster();
				control = new TransformControls( camera, renderer.domElement );
				control.addEventListener( 'dragging-changed', function ( event ) {

					if ( ! event.value ) {

						const points = curve.getPoints( 50 );

						console.log(points);
						line.geometry.setFromPoints( points );
						flow.updateCurve( 0, curve );

					}

				} );



				const matChanger = function ( ) {

bokehPass.uniforms[ 'focus' ].value = params.focus;
bokehPass.uniforms[ 'aperture' ].value = params.aperture * 0.00001;
bokehPass.uniforms[ 'maxblur' ].value = params.maxblur;

};
/*
const gui = new GUI();
gui.add( params, 'focus', 10.0, 3000.0, 10 ).onChange( matChanger );
gui.add( params, 'aperture', 0, 10, 0.1 ).onChange( matChanger );
gui.add( params, 'maxblur', 0.0, 0.01, 0.001 ).onChange( matChanger );
gui.close();*/

matChanger();



			}

			function onWindowResize() {
				const width = window.innerWidth;
				const height = window.innerHeight;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				composer.setSize( width, height );
				pixelPass.uniforms[ 'resolution' ].value.set( window.innerWidth, window.innerHeight ).multiplyScalar( window.devicePixelRatio );

			}

			function onPointerDown( event ) {

action = ACTION_SELECT;
mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

}

			function animate() {

				requestAnimationFrame( animate );

				stats.begin();
				const time = - performance.now() * 0.0003;
				
				uniforms.dT.value = clock.getDelta();
   			 uniforms.time.value += uniforms.dT.value;

				camera.position.x =100 * Math.cos( time * 1 );// - 100;
				camera.position.z = 400;//* Math.sin( time );
				camera.lookAt( scene.position );

				//light.position.x = Math.sin( time * 1.7 ) * 30;
				//light.position.y = Math.cos( time * 1.5 ) * 40;
				//light.position.z = Math.cos( time * 1.3 ) * 30;

			//	spiralGeo.rotation.y += .03;

				//if ( vnh ) vnh.update();
				//if ( vth ) vth.update();

				//renderer.render( scene, camera );


				if ( action === ACTION_SELECT ) {

rayCaster.setFromCamera( mouse, camera );
action = ACTION_NONE;
const intersects = rayCaster.intersectObjects( curveHandles, false );
if ( intersects.length ) {

	const target = intersects[ 0 ].object;
	control.attach( target );
	scene.add( control );

}

}


//lorenz.rotation.y += .001;

lorenz.rotation.z = .3* Math.cos( time * 3 ) + Math.PI / 2;
				composer.render();

				
				stats.end();

			}



			function addLoad(){
    neededToLoad ++;
  }

  function onLoad(){
    numLoaded ++;
    if( numLoaded == neededToLoad ){
      init();
      animate();
    }
  }


		</script>

	</body>
</html>
