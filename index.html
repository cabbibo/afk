<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - helpers</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="preload" href="fonts/FT88-Expanded.ttf" as="font" type="font/ttf" crossorigin>
		<!--<link type="text/css" rel="stylesheet" href="main.css">-->
		<style>

#info {
	position: absolute;
	bottom: 10px;
	right: 20px;
	width: 100%;
	float:right;
	text-align:right;
	z-index: 1;
			//	margin-left: auto;
			//	margin-right: auto;
				visibility: hidden;
			}


			#lineup {
	position: absolute;
	top: 10px;
	left: 20px;
	width: 100%;
	float:left;
	text-align:left;
	z-index: 1;
				margin-left: auto;
				margin-right: auto;
				visibility: hidden;
			}
					

			#lineup:a{

				display:block;
			}
					
			
			@font-face {
			font-family: "ft88";
			src: url("fonts/FT88-Expanded.ttf");
			}

			body {
				margin: 0;
				color: #000;
				width:100%;
				font-size: 10px;
				line-height:16px;
				overscroll-behavior: none;
				background:#feffe4;
				font-family: "ft88";
				overflow:hidden;
				
			}

			a{
				color:rgba(0, 0, 0, 0.5);
				text-decoration: none;
			}
			a:visited{
				color:rgba(0, 0, 0, 0.5);
				text-decoration: none;
			}
			a:hover{
				color:#000;
			}
			.lil-gui { 
	--width: 500px;
	--name-width: 15%;
	--font-family:"ft88";
	--background: #f00;

}


			#renderer{
				margin:0px;
				height:100%;
				width:100%;
				left:0px;
				position:absolute;
			}

			#stats{
				bottom:0px;
				position:absolute;
				font-family:"ft88";
				visibility: hidden;
			}

			#loadBar{
				width: 0%;
				left:0px;
				height:20px;
				position:fixed;
				top:50%;
				//background:rgb(0, 0, 0);
				border-bottom:#000 1px solid;
				z-index: 9999;
			}

			#startButton{
				color:#000;
				position: absolute;
				text-decoration: underline;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
			}

			#imgLinks{
				position:fixed;
				bottom:0px;
				left:10px;
				width:100px;

				z-index:9999;
				visibility: hidden;
				opacity: .7;
			}
			#imgLinks a:hover{
				border-bottom:1px solid black;
				opacity:1;
			}

			#imgLinks:hover{
				//opacity:1;
			}
		
			</style>
	</head>
	<body>

		<div id="loadBar"></div>

		<div id="lineup">


			<a href="https://www.twitch.tv/pcmusicinfo" target="_blank">
				Ö<br/>
				A. G. Cook<br/>
				Alex Somers<br/>
				BASECK<br/>
				BOPPLES<br/>
				caro<3<br/>
				Holly Waxwing<br/>
				Kai Whiston<br/>
				Lecx Stacy<br/>
				Regina Demina<br/>
				Timothée Joly<br/>
			</a>
		</div>

		<div id="info">
			<a href="https://www.twitch.tv/pcmusicinfo" target="_blank">

				2pm LA<br/> 5pm NY <br/> 10pm London<br/>
				December 11th<br/>
				twitch.tv/pcmusicinfo
			</a>
			
			
		</div>

		<div id="imgLinks">
			<a href="https://youtu.be/qPfSV6Bvfzk" style="width:100%;"><img src="img/hyper2.png" style="width:40%;"/></a>
			<a href="https://pcmusic.bandcamp.com/" style="width:100%;"><img src="img/bcSquare.png" style="width:40%;"/></a>
		</div>

		<script src="lib/jquery.min.js"></script>
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>




		

		<script type="module">

			import * as THREE from 'three';
import {
	Box3,
	MathUtils,
	Matrix4,
	Matrix3,
	Ray,
	Vector3,
	Color,
} from 'three';

import{ ShaderLoader } from './lib/ShaderLoader.js';

			import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			

			import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
			
			import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

			import * as Curves from 'three/addons/curves/CurveExtras.js';
			
			//import Stats from 'three/addons/libs/stats.module.js';
			//import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			const ACTION_SELECT = 1, ACTION_NONE = 0;
			const curveHandles = [];
			const mouse = new THREE.Vector2();

			let scene, renderer;
			let camera, light;
			let vnh;
			let vth;
			let composer,  mixer;
			let pixelPass,	control,
				flow, rayCaster,
				action = ACTION_NONE;

				let stats;



				let curveRep;
			var neededToLoad = 0;
			var numLoaded = 0;

			var shaders = new ShaderLoader( 'shaders' );


			addLoad();

			addLoad();
			shaders.load( 'fs-trace3'  , 'trace2' , 'fragment' );

			addLoad();
shaders.load( 'vs-trace2'  , 'trace2' , 'vertex'   );

addLoad();
shaders.load( 'fs-trace'  , 'trace' , 'fragment' );

addLoad();
shaders.load( 'vs-trace'  , 'trace' , 'vertex'   );
addLoad();
shaders.load( 'vs-gradient'  , 'gradient' , 'vertex'   );
addLoad();
shaders.load( 'fs-gradient'  , 'gradient' , 'fragment'   );

shaders.shaderSetLoaded = function(){

	console.log("LOADED");
  onLoad();
}
shaders.endLoad = function(){
	onLoad();
}




function openFullscreen(elem) {
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { /* Safari */
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { /* IE11 */
    elem.msRequestFullscreen();
  }
}



  	const objLoader = new OBJLoader();
	var afkModel;

	addLoad();
	objLoader.load( 'img/afk_lowerCase2.obj', function ( gltf ) {
		onLoad();
		afkModel = gltf.children[ 0 ];

	} );

	var rockModel;




var tubeModel;

addLoad();
objLoader.load( 'cone.obj', function ( gltf ) {

console.log("hiii");

tubeModel = gltf.children[ 0 ];
console.log(tubeModel);
onLoad();

} );









	
	var uniforms = {

dT:       { type:"f"  , value : 0             },
time:     { type:"f"  , value : 0             },
lightPos: { type:"v3" , value : null          },

_NoiseSize:{type:"f",value:.27},
_NoiseSpeed:{type:"f",value:.35},
_NoiseOffset:{type:"f",value:.1},
_HueStart:{type:"f",value:.1},
_HueSize:{type:"f",value:.0021},
_NormalDepth:{type:"f",value:1.1},
_FFTStart:{type:"f",value:.1},
_FFTSize:{type:"f",value:.1},
_Saturation:{type:"f",value:.4},
_Lightness:{type:"f",value:.3},
_DiscardAmount:{type:"f",value:.9},
_TargetPos:{type:"v3",value: new THREE.Vector3()},

_Opacity:{type:"f",value:.1},
_OffsetStepResolution:{type:"f",value:1},
_OpacityFalloffSpeed:{type:"f",value:2},
_GravitySize:{type:"f",value:50},

_BGHueMin : {type:"f",value:0.08, min: 0, max:1},
_BGHueMax : {type:"f",value:.1, min: 0, max:1},
_BGHueSize : {type:"f",value:10, min: 0, max:100},
_BGHueSpeed : {type:"f",value:11, min: 0, max:11},
_BGSaturationMin : {type:"f",value:.25, min: 0, max:1},
_BGSaturationMax : {type:"f",value:.3, min: 0, max:1},
_BGSaturationSize : {type:"f",value:15.8, min: 0, max:100},
_BGSaturationSpeed : {type:"f",value:10, min: 0, max:100},
_BGLightnessMin : {type:"f",value:0.7, min: 0, max:1},
_BGLightnessMax : {type:"f",value:.9, min: 0, max:1},
_BGLightnessSize : {type:"f",value:8, min: 0, max:100},
_BGLightnessSpeed : {type:"f",value:4, min: 0, max:100}

}



var lorenzParams = {
		x0: 0.1,
		y0: 0,
		z0: 0, 
		h : 0.001,
		a :19	,
		b : 58,
		c : 1.6,
		startY:.1,
		scale: 3.5,
		yOffset:120,
		thickness:.5,
		opacity:.3,
		wireframe:false

  }

var lorenz
const params = {
				exposure: 0,
				bloomStrength:5,
				bloomThreshold: .4,
				bloomRadius: 1,	


				shape: 10,
					radius: 1,
					rotateR: Math.PI / 12,
					rotateB: Math.PI / 12 * 4,
					rotateG: Math.PI / 12 * 6,
					scatter: .3,
					blending: 1,
					blendingMode: 9,
					greyscale: false,
					disable: false,
					pixelSize: 2,
					postprocessing: true,
					
					focus: 200.0,
					aperture: 10,
					maxblur: 0.01

					
			};


var clock = new THREE.Clock();


var spiralGeo;
let fontGeo;
let fontGeo2;
let lorenzCurve;

			//init();
			//animate();

			function init() {





	




				renderer = new THREE.WebGLRenderer( { alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.domElement.id = "renderer";
				//renderer.info.alpha = true;
				document.body.appendChild( renderer.domElement );

			

				
				/*stats = new Stats();
				stats.dom.id = "stats";
				stats.dom.style = "";
				document.body.appendChild( stats.dom );*/

				//renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.setClearColor(0x00f000, 1)

				//

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 4, 40000 );
				camera.position.z = 400;


				if( /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) ) {
					// some code..
					console.log("hji");
					camera.position.z = 600;
					document.body.style.fontSize ="8px";
					document.body.style.lineHeight ="10px";
					//document.body.style.letterSpacing ="-.2em";
				}

				scene = new THREE.Scene();
				scene.background = null;

				//light = new THREE.PointLight();
				//light.position.set( 200, 100, 150 );
				//scene.add( light );

			



				var size = 1;

				var initialPoints = []
				for( var i = 0; i < 100; i++ ){


					var angle = i * .5;
					var radius = .005 * i + 2 ;
					var height = .01;

					

					var p = {
						x: -Math.cos( angle ) * radius,
						z: Math.sin(angle) * radius,
						y: i * height - 1
					}
					initialPoints.push(p);

				}


				
				var initialPoints = []
				for( var i = 0; i < 10; i++ ){


					var angle = (i /10)* 2 * Math.PI;
					var radius = 2 ;
					var height = .01;

					

					var p = {
						x: -Math.cos( angle ) * radius,
						z: Math.sin(angle) * radius,
						y: 0
					}
					initialPoints.push(p);

				}


				const boxGeometry = new THREE.BoxGeometry( 40,40, 40);
				const boxMaterial = new THREE.MeshBasicMaterial({color:0x00ff00});

				for ( const handlePos of initialPoints ) {

					const handle = new THREE.Mesh( boxGeometry, boxMaterial );
					handle.position.copy( handlePos );
					curveHandles.push( handle );
					//scene.add( handle );

				}

				const curve = new THREE.CatmullRomCurve3(
					curveHandles.map( ( handle ) => handle.position )
				);
				curve.curveType = 'centripetal';
				curve.closed = true;

				const points = curve.getPoints( 20 );
				const line = new THREE.LineLoop(
					new THREE.BufferGeometry().setFromPoints( points ),
					new THREE.LineBasicMaterial( { color: 0x00ff00 } )
				);


	

				const group = new THREE.Group();
				group.scale.multiplyScalar( 100 );
				group.rotation.x = 3.14159/2
				scene.add( group );


				// a point to move along the lorenz attractor
				var boxGeometry1 = new THREE.IcosahedronGeometry( 2,1);
				var boxMaterial1 = new THREE.MeshBasicMaterial({color:0x000000,wireframe:true});
				curveRep = new THREE.Mesh( boxGeometry1, boxMaterial1 );
				scene.add( curveRep );

				group.updateMatrixWorld( true );
	
				SetNewLorenz();



				// Our background object!
				var raytraceMat2 = new THREE.ShaderMaterial({
					uniforms: uniforms,
					vertexShader: shaders.vs.trace2,
					fragmentShader: shaders.fs.trace2,
					side: THREE.DoubleSide,
				})



				var bg = new THREE.Mesh( tubeModel.geometry , raytraceMat2 );
				
				var s = 10;
				bg.position.y = 1;
				bg.rotation.x = Math.PI;
				bg.scale.set(s,s*10,s);
				group.add(bg);








				//
				var raytraceMat = new THREE.ShaderMaterial({
					uniforms: uniforms,
					vertexShader: shaders.vs.trace,
					fragmentShader: shaders.fs.trace,
					side: THREE.DoubleSide,
					depthTest: false,
					wireframe : true,
					transparent: true,
				})


				var pretty = new THREE.Mesh( afkModel.geometry , raytraceMat);
				group.add( pretty );

			


		


				var myGradient = new THREE.Mesh(
  new THREE.PlaneGeometry(20,20,1,1),
  new THREE.ShaderMaterial({
    uniforms: uniforms,
        vertexShader: shaders.vs.gradient,
        fragmentShader: shaders.fs.gradient
  })
)

myGradient.material.depthWrite = false
myGradient.renderOrder = -99999
myGradient.position.x = 100

scene.add(myGradient);


			

				window.addEventListener( 'resize', onWindowResize );


				const renderScene = new RenderPass( scene, camera );



const effectFilm = new FilmPass( .5, 0.005, -648, false );

composer = new EffectComposer( renderer );
composer.addPass( renderScene );
composer.addPass(effectFilm);






		
/*

const gui = new GUI();


//gui.add( params, 'maxblur', 0.0, 0.01, 0.001 ).onChange( matChanger );


var text = gui.addFolder("TEXT")

text.add( uniforms._NoiseOffset, 'value', 0, 2. ).name( 'Noise Offset' )
text.add( uniforms._NoiseSize, 'value', 0, 10. ).name( 'Noise Size' )
text.add( uniforms._NoiseSpeed, 'value', 0, 2. ).name( 'Noise Speed' )
text.add( uniforms._HueStart, 'value', 0, 1. ).name( '_HueStart' )
text.add( uniforms._HueSize, 'value', 0, .01 ).name( '_HueSize' )
text.add( uniforms._Saturation, 'value', 0, 1 ).name( '_Saturation' )
text.add( uniforms._Lightness, 'value', 0, 1 ).name( '_Lightness' )
text.add( uniforms._Opacity, 'value', 0, 1 ).name( '_Opacity' )
text.add( uniforms._OffsetStepResolution, 'value', 0, 1000).name( '_OffsetStepResolution' )
text.add( uniforms._OpacityFalloffSpeed, 'value', 0, 1000 ).name( '_OpacityFalloffSpeed' )
text.add( uniforms._GravitySize, 'value', 0, 1000 ).name( '_GravitySize' )

text.close()

var background = gui.addFolder("BACKGROUND")



background.add( uniforms._BGHueMin, 'value',uniforms._BGHueMin.min, uniforms._BGHueMin.max).name('_BGHueMin');
background.add( uniforms._BGHueMax, 'value',uniforms._BGHueMax.min, uniforms._BGHueMax.max).name('_BGHueMax');
background.add( uniforms._BGHueSize, 'value',uniforms._BGHueSize.min, uniforms._BGHueSize.max).name('_BGHueSize');
background.add( uniforms._BGHueSpeed, 'value', uniforms._BGHueSpeed.min, uniforms._BGHueSpeed.max).name('_BGHueSpeed');
background.add( uniforms._BGSaturationMin, 'value', uniforms._BGSaturationMin.min, uniforms._BGSaturationMin.max).name('_BGSaturationMin');
background.add( uniforms._BGSaturationMax, 'value', uniforms._BGSaturationMax.min, uniforms._BGSaturationMax.max).name('_BGSaturationMax');
background.add( uniforms._BGSaturationSize, 'value', uniforms._BGSaturationSize.min, uniforms._BGSaturationSize.max).name('_BGSaturationSize');
background.add( uniforms._BGSaturationSpeed, 'value', uniforms._BGSaturationSpeed.min, uniforms._BGSaturationSpeed.max).name('_BGSaturationSpeed');
background.add( uniforms._BGLightnessMin, 'value', uniforms._BGLightnessMin.min, uniforms._BGLightnessMin.max).name('_BGLightnessMin');
background.add( uniforms._BGLightnessMax, 'value',uniforms._BGLightnessMax.min, uniforms._BGLightnessMax.max).name('_BGLightnessMax');
background.add( uniforms._BGLightnessSize, 'value',uniforms._BGLightnessSize.min, uniforms._BGLightnessSize.max).name('_BGLightnessSize');
background.add( uniforms._BGLightnessSpeed, 'value', uniforms._BGLightnessSpeed.min, uniforms._BGLightnessSpeed.max).name('_BGLightnessSpeed');


background.close();

var lorenzGUI = gui.addFolder("lorenz")

lorenzGUI.add( lorenzParams, 'a', 0, 40. ).name( 'a' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'b', 0, 80. ).name( 'b' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'c', 0, 3. ).name( 'c' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'scale', 0, 30. ).name( 'scale' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'x0', 0, 3. ).name( 'x0' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'y0', 0, 3. ).name( 'y0' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'z0', 0, 3. ).name( 'z0' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'yOffset', 0, 300. ).name( 'yOffset' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'thickness', 0, 10. ).name( 'thickness' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'opacity', 0, 1. ).name( 'opacity' ).onChange( SetNewLorenz )
lorenzGUI.add( lorenzParams, 'wireframe' ).name( 'wireframe' ).onChange( SetNewLorenz )
lorenzGUI.close();
let preset = {};

gui.close();
*/




			}

			function onWindowResize() {
				const width = window.innerWidth;
				const height = window.innerHeight;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				composer.setSize( width, height );
				
			}



			function animate() {

				requestAnimationFrame( animate );

				//stats.begin();
				const time = - performance.now() * 0.0003;
				
				uniforms.dT.value = clock.getDelta();
   			 	uniforms.time.value += uniforms.dT.value;

				camera.position.x =100 * Math.cos( time * 1 );// - 100;
			//	camera.position.z = 400;//* Math.sin( time );
				camera.lookAt( scene.position );

				//light.position.x = Math.sin( time * 1.7 ) * 30;
				//light.position.y = Math.cos( time * 1.5 ) * 40;
				//light.position.z = Math.cos( time * 1.3 ) * 30;

			//	spiralGeo.rotation.y += .03;

				//if ( vnh ) vnh.update();
				//if ( vth ) vth.update();

				//renderer.render( scene, camera );


				lorenz.updateMatrixWorld(true)

				var c = lorenzCurve.getPointAt(Math.sin( time * .02) * .5 + .5 );
				//console.log(lorenz.matrix);
				c.applyMatrix4(lorenz.matrix);
				curveRep.position.copy( c);
				uniforms._TargetPos.value.copy(c);



//lorenz.rotation.y += .001;

//lorenz.rotation.z = .3* Math.cos( time * 3 ) + Math.PI / 2;
				composer.render();

				
				//stats.end();

			}



			function addLoad(){
    neededToLoad ++;
  }

  function onLoad(){
    numLoaded ++;
	setLoadBar();
    if( numLoaded == neededToLoad ){
	//	addStartButton();
      init();
      animate();
	  	info.style.visibility = "visible";
	lineup.style.visibility = "visible";
	imgLinks.style.visibility = "visible";
    }
  }


var loadBar = document.getElementById("loadBar");
var lineup = document.getElementById("lineup");
var info = document.getElementById("info");
var imgLinks = document.getElementById("imgLinks");
	info.style.visibility = "hidden";
	lineup.style.visibility = "hidden";
	imgLinks.style.visibility = "hidden";

	loadBar.style.visibility = "hidden";

function setLoadBar(){

	console.log(loadBar);
	

	var p = numLoaded / neededToLoad;
	console.log(p);

	loadBar.style.width = (p * 100) + "%"


}

function addStartButton(){
	init();
	let btn = document.createElement("a");
	btn.id ="startButton";
	btn.innerHTML = "away from keyboard";
	btn.onclick = doClick;
	loadBar.appendChild(btn);

}


var doClick = function(){
	loadBar.style.visibility="hidden";
	document.body.removeChild(loadBar);
	console.log("hg");
	console.log(renderer);

	setTimeout(fullStart, 50);
	
}

var fullStart = function(){
	
/*	var lockFunction =  window.screen.orientation.lock;
	if (lockFunction.call(window.screen.orientation, 'landscape')) {
			//console.log('Orientation locked')
	} else {
			//console.error('There was a problem in locking the orientation')
	}

	//info.style.visibility = "visible";
	//lineup.style.visibility = "visible";
	//imgLinks.style.visibility = "visible";
	openFullscreen(document.body);*/
	animate();
}

  function SetNewLorenz(){

	console.log("THIS HAPPENEd");
	var lor = []

let x0 = lorenzParams.x0;
let y0 = lorenzParams.y0;
let z0 = lorenzParams.z0; 
let x1, y1, z1;
let h = lorenzParams.h;
let a = lorenzParams.a;
let b = lorenzParams.b;
let c = lorenzParams.c;


var len = 100000;
for (let i = 0; i < len; i++) {
x1 = x0 + h * a * (y0 - x0);
y1 = y0 + h * (x0 * (b - z0) - y0);
z1 = z0 + h * (x0 * y0 - c * z0);
x0 = x1;
y0 = y1;
z0 = z1;
let vertex = new THREE.Vector3(
 x0, 
 y0, 
 z0-24);
lor.push(vertex);
}


var lorGroup = new THREE.Group();

lorGroup.rotation.x = Math.PI / 2;
lorGroup.rotation.z = Math.PI / 2;
//lorGroup.rotation.x = 3.14159/2
lorGroup.position.y = lorenzParams.yOffset;
var s = lorenzParams.scale;
lorGroup.scale.set(s,s,s);


//group.add(lorGroup);;

lorGroup.updateMatrixWorld( true );
//console.log(lor.length);


for( let i = 0; i < lor.length; i++ ){
	lor[i] = lor[i].applyMatrix4( lorGroup.matrix );
}


   var curve2 = new THREE.CatmullRomCurve3(lor
		   );
		   curve2.curveType = 'centripetal';
		   curve2.closed = false;



		   var matte = new THREE.MeshBasicMaterial({
			color: new THREE.Color(0,0,0), 
			transparent:true,
			opacity: lorenzParams.opacity,
			wireframe: lorenzParams.wireframe
		});

		lorenzCurve = curve2;

var tubeGeometry2 = new THREE.TubeGeometry( curve2,10000, lorenzParams.thickness, 3 );

	 var pretty  =new THREE.Mesh( tubeGeometry2 , matte);
   
if( lorenz ){
	scene.remove(lorenz);
}

   lorenz = pretty;

   scene.add(pretty);
  }

		</script>

	</body>
</html>
